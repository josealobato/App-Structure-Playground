# Initial requirements

Build an application that fetches data from this API - [https://randomuser.me](https://randomuser.me/) - and displays a list of Users. 
The application shouldÂ fetch multiple pages of Users from that API and display a list of Users with first and last names on one line and the email below. 
Following pages should be fetched when users scroll the list. 
Finally, while offline, previously loaded Users should still be accessible from the list. 

# Comments on the implementation

(The architecture is explained in the readme at the root of the app `BaseApp/BaseApp/README.md`)

Here are some facts about the exercise to take into account:

* I focus on structure more than on the feature.
* This is not production code.
* **Please ignore the extra feature**. There is an additional feature that shows on the second page. I left it there for demonstration, but it is not for review. That also affects its adaptor, workers, and repository.
* Very rudimentary implementation of the pagination.
* Very rudimentary implementation of local storage with CoreData.
* Very rudimentary implementation of Connectivity with a new framework (I last did that a while ago).
* I did not test it on the device. 
* I added an artificial page limit to test the last page (see `artificialPageLimit` in the `UserRepository`)
* I added a small explanation about the possible cache strategies on the `README.md` file on the `Repositories` package. Two strategies are inplemented but only one in use.

# What is missing:

Of course, many things are missing, but these are the most painful to me:

* **Error management**. You can see better error management reading on the data layer with the `RepositoryError` and its builder. But I did not move that up in the chain. Also, on the `Interactor`, the error rendering does nothing.
* **View States**. There should be view states for the following states at least: no data, connection, error, loading, etc.
* **Tests**. You can see that there are mocks to all protocols generated by running `rake mocks` where the `Rakefile` is (base of the project). If you'd like to see how I unit test some code, you could visit the coordinator tests included in this PR. Notice that the coordinator was not developed in the context of this exercise.
* **Workers**: I did not include the workers because they are not needed for this small feature, but they are an important piece to increase reusability in this architecture.
* **Localization**: Many strings are hardcoded. They should be included in the right string files to be able to apply localizations.

# Videos:

**NOTE: Sorry, I know I talk too fast in the videos; I do not want them to be too long!**

(Videos are hosted at Vimeo since Github only allows for 10Mb videos. Please get in touch with me if you can not see them.)

## Video 1: About Architecture, quality and scalability

I briefly introduce the architecture in this first video to help understand the goal.

[see the video](https://vimeo.com/870642493?share=copy)

## Video 2: Intro to features

Features are the building blocks of the application, and they can be built internally in many ways; here I explain one.

[see the video](https://vimeo.com/870647592?share=copy)

## Video 3: The quick data layer.

Unfortunately, I do not have more space on Vimeo, so I could not upload it.

# Extra information

The structure used in this demo project is the same one I used on one of my open-source projects (https://github.com/josealobato/ratpenat)

